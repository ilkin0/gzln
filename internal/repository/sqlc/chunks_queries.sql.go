// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunks_queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const chunkExistsByFileIdAndIndex = `-- name: ChunkExistsByFileIdAndIndex :one
SELECT EXISTS(
  SELECT 1
  FROM chunks
  WHERE file_id = $1 and chunk_index = $2
)
`

type ChunkExistsByFileIdAndIndexParams struct {
	FileID     pgtype.UUID `json:"file_id"`
	ChunkIndex int32       `json:"chunk_index"`
}

func (q *Queries) ChunkExistsByFileIdAndIndex(ctx context.Context, arg ChunkExistsByFileIdAndIndexParams) (bool, error) {
	row := q.db.QueryRow(ctx, chunkExistsByFileIdAndIndex, arg.FileID, arg.ChunkIndex)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countChunksByFileId = `-- name: CountChunksByFileId :one
SELECT
    COUNT(ID)
FROM chunks
WHERE file_id = $1
`

func (q *Queries) CountChunksByFileId(ctx context.Context, fileID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChunksByFileId, fileID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (
    file_id,
    chunk_index,
    storage_path,
    encrypted_size,
    chunk_hash
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id
`

type CreateChunkParams struct {
	FileID        pgtype.UUID `json:"file_id"`
	ChunkIndex    int32       `json:"chunk_index"`
	StoragePath   string      `json:"storage_path"`
	EncryptedSize int64       `json:"encrypted_size"`
	ChunkHash     string      `json:"chunk_hash"`
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (int64, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.FileID,
		arg.ChunkIndex,
		arg.StoragePath,
		arg.EncryptedSize,
		arg.ChunkHash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const fileExistsByIdAndStatus = `-- name: FileExistsByIdAndStatus :one
SELECT EXISTS(
  SELECT 1
  FROM files
  WHERE id = $1 and status = $2
)
`

type FileExistsByIdAndStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) FileExistsByIdAndStatus(ctx context.Context, arg FileExistsByIdAndStatusParams) (bool, error) {
	row := q.db.QueryRow(ctx, fileExistsByIdAndStatus, arg.ID, arg.Status)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getChunkByIndexAndFileShareID = `-- name: GetChunkByIndexAndFileShareID :one
SELECT
    f.max_downloads,
    f.download_count,
    c.storage_path
FROM chunks c
JOIN files f on f.id = c.file_id
WHERE f.share_id = $1 and c.chunk_index = $2
  AND f.status = 'ready' AND f.expires_at > NOW()
`

type GetChunkByIndexAndFileShareIDParams struct {
	ShareID    string `json:"share_id"`
	ChunkIndex int32  `json:"chunk_index"`
}

type GetChunkByIndexAndFileShareIDRow struct {
	MaxDownloads  int32  `json:"max_downloads"`
	DownloadCount int32  `json:"download_count"`
	StoragePath   string `json:"storage_path"`
}

func (q *Queries) GetChunkByIndexAndFileShareID(ctx context.Context, arg GetChunkByIndexAndFileShareIDParams) (GetChunkByIndexAndFileShareIDRow, error) {
	row := q.db.QueryRow(ctx, getChunkByIndexAndFileShareID, arg.ShareID, arg.ChunkIndex)
	var i GetChunkByIndexAndFileShareIDRow
	err := row.Scan(&i.MaxDownloads, &i.DownloadCount, &i.StoragePath)
	return i, err
}
