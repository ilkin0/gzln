// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files_queries.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeFileDownloadByShareId = `-- name: CompleteFileDownloadByShareId :one
WITH updated AS (
    UPDATE files
        SET
            download_count = download_count + 1,
            last_downloaded_at = now()
        WHERE share_id = $1
            AND status = 'ready'
            AND (max_downloads = 0 OR download_count < max_downloads)
            AND (expires_at IS NULL OR expires_at > now())
        RETURNING id, share_id, download_count, max_downloads, expires_at)
SELECT u.id,
       u.share_id,
       u.download_count,
       u.max_downloads,
       (u.max_downloads > 0 AND u.download_count = u.max_downloads) AS reached_limit,
       expires_at
FROM updated u
`

type CompleteFileDownloadByShareIdRow struct {
	ID            pgtype.UUID        `json:"id"`
	ShareID       string             `json:"share_id"`
	DownloadCount int32              `json:"download_count"`
	MaxDownloads  int32              `json:"max_downloads"`
	ReachedLimit  pgtype.Bool        `json:"reached_limit"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CompleteFileDownloadByShareId(ctx context.Context, shareID string) (CompleteFileDownloadByShareIdRow, error) {
	row := q.db.QueryRow(ctx, completeFileDownloadByShareId, shareID)
	var i CompleteFileDownloadByShareIdRow
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.DownloadCount,
		&i.MaxDownloads,
		&i.ReachedLimit,
		&i.ExpiresAt,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    share_id,
    encrypted_filename,
    encrypted_mime_type,
    salt,
    pbkdf2_iterations,
    total_size,
    chunk_count,
    chunk_size,
    expires_at,
    max_downloads,
    deletion_token_hash,
    uploader_ip
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, share_id, encrypted_filename, encrypted_mime_type, salt, pbkdf2_iterations, total_size, chunk_count, chunk_size, status, created_at, expires_at, last_downloaded_at, max_downloads, download_count, deletion_token_hash, uploader_ip
`

type CreateFileParams struct {
	ShareID           string             `json:"share_id"`
	EncryptedFilename string             `json:"encrypted_filename"`
	EncryptedMimeType string             `json:"encrypted_mime_type"`
	Salt              string             `json:"salt"`
	Pbkdf2Iterations  int32              `json:"pbkdf2_iterations"`
	TotalSize         int64              `json:"total_size"`
	ChunkCount        int32              `json:"chunk_count"`
	ChunkSize         int32              `json:"chunk_size"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	MaxDownloads      int32              `json:"max_downloads"`
	DeletionTokenHash pgtype.Text        `json:"deletion_token_hash"`
	UploaderIp        netip.Addr         `json:"uploader_ip"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.ShareID,
		arg.EncryptedFilename,
		arg.EncryptedMimeType,
		arg.Salt,
		arg.Pbkdf2Iterations,
		arg.TotalSize,
		arg.ChunkCount,
		arg.ChunkSize,
		arg.ExpiresAt,
		arg.MaxDownloads,
		arg.DeletionTokenHash,
		arg.UploaderIp,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.EncryptedFilename,
		&i.EncryptedMimeType,
		&i.Salt,
		&i.Pbkdf2Iterations,
		&i.TotalSize,
		&i.ChunkCount,
		&i.ChunkSize,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastDownloadedAt,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.DeletionTokenHash,
		&i.UploaderIp,
	)
	return i, err
}

const deleteExpiredFiles = `-- name: DeleteExpiredFiles :exec
DELETE FROM files
WHERE expires_at < now() OR (max_downloads <= download_count AND status = 'ready')
`

func (q *Queries) DeleteExpiredFiles(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredFiles)
	return err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, share_id, encrypted_filename, encrypted_mime_type, salt, pbkdf2_iterations, total_size, chunk_count, chunk_size, status, created_at, expires_at, last_downloaded_at, max_downloads, download_count, deletion_token_hash, uploader_ip FROM files
WHERE id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.EncryptedFilename,
		&i.EncryptedMimeType,
		&i.Salt,
		&i.Pbkdf2Iterations,
		&i.TotalSize,
		&i.ChunkCount,
		&i.ChunkSize,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastDownloadedAt,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.DeletionTokenHash,
		&i.UploaderIp,
	)
	return i, err
}

const getFileByShareID = `-- name: GetFileByShareID :one
SELECT id, share_id, encrypted_filename, encrypted_mime_type, salt, pbkdf2_iterations, total_size, chunk_count, chunk_size, status, created_at, expires_at, last_downloaded_at, max_downloads, download_count, deletion_token_hash, uploader_ip FROM files
WHERE share_id = $1
`

func (q *Queries) GetFileByShareID(ctx context.Context, shareID string) (File, error) {
	row := q.db.QueryRow(ctx, getFileByShareID, shareID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.EncryptedFilename,
		&i.EncryptedMimeType,
		&i.Salt,
		&i.Pbkdf2Iterations,
		&i.TotalSize,
		&i.ChunkCount,
		&i.ChunkSize,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastDownloadedAt,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.DeletionTokenHash,
		&i.UploaderIp,
	)
	return i, err
}

const getFileMetadataByShareId = `-- name: GetFileMetadataByShareId :one
SELECT encrypted_filename,
       encrypted_mime_type,
       salt,
       total_size,
       chunk_count,
       expires_at,
       max_downloads,
       download_count
FROM files
WHERE share_id = $1
`

type GetFileMetadataByShareIdRow struct {
	EncryptedFilename string             `json:"encrypted_filename"`
	EncryptedMimeType string             `json:"encrypted_mime_type"`
	Salt              string             `json:"salt"`
	TotalSize         int64              `json:"total_size"`
	ChunkCount        int32              `json:"chunk_count"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	MaxDownloads      int32              `json:"max_downloads"`
	DownloadCount     int32              `json:"download_count"`
}

func (q *Queries) GetFileMetadataByShareId(ctx context.Context, shareID string) (GetFileMetadataByShareIdRow, error) {
	row := q.db.QueryRow(ctx, getFileMetadataByShareId, shareID)
	var i GetFileMetadataByShareIdRow
	err := row.Scan(
		&i.EncryptedFilename,
		&i.EncryptedMimeType,
		&i.Salt,
		&i.TotalSize,
		&i.ChunkCount,
		&i.ExpiresAt,
		&i.MaxDownloads,
		&i.DownloadCount,
	)
	return i, err
}

const getFileSaltByShareId = `-- name: GetFileSaltByShareId :one
SELECT
    salt
FROM files
WHERE share_id = $1
`

func (q *Queries) GetFileSaltByShareId(ctx context.Context, shareID string) (string, error) {
	row := q.db.QueryRow(ctx, getFileSaltByShareId, shareID)
	var salt string
	err := row.Scan(&salt)
	return salt, err
}

const updateFileStatus = `-- name: UpdateFileStatus :one
UPDATE files
SET status = $2
WHERE id = $1
RETURNING id, share_id, encrypted_filename, encrypted_mime_type, salt, pbkdf2_iterations, total_size, chunk_count, chunk_size, status, created_at, expires_at, last_downloaded_at, max_downloads, download_count, deletion_token_hash, uploader_ip
`

type UpdateFileStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateFileStatus(ctx context.Context, arg UpdateFileStatusParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFileStatus, arg.ID, arg.Status)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ShareID,
		&i.EncryptedFilename,
		&i.EncryptedMimeType,
		&i.Salt,
		&i.Pbkdf2Iterations,
		&i.TotalSize,
		&i.ChunkCount,
		&i.ChunkSize,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastDownloadedAt,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.DeletionTokenHash,
		&i.UploaderIp,
	)
	return i, err
}
